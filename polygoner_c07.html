<html>
	<head>
	<style type="text/css">
		  canvas { border: 1px solid black; }
	</style>

	<script type="text/javascript" src="stabilaFunk.js"></script>
	<script type="text/javascript" src="testFunk.js"></script>
	<script type="text/javascript" src="drawGraphic.js"></script>

	<script type="application/javascript">

	//DONE
	//högerklick på segment tar bort segmentet och öppnar polygonen?
	//ändra startpunkt i segmentArray 
	//rensa bort punktArray ur koden  
	//implementera polygon.seedPoint  
	//hantera ifall alla punkter raderas kunna "radera" seedPoint
	//efter vilka förändringar på en redigering på en stängd polygon måste man köra Gauss shoe lace formula?
	//applicera modulotänket i checkIfMovedIntersects på funktionen ejectPoint?

	//MUST HAVE
	//granska koden
	//testa ordentligt
	//ta bort "console.log"
	//slumpa runt punkter så alla polygoner får en area som ligger närmare genomsnittet (beräkning nyArea endast för polygoner som har flyttad punkt)
	//Skriva kommentarer på engelska
	//ha engelska namn på variabler och funktioner
	//checkbox för att välja om non-complex polygon ska vara tvingande
	//BUG: kolla att det fortfarande är en non-complex polygon när man raderat en punkt. Annars inte tillåta? eller radera båda närliggande segment?
	//Radera funktioner som inte används
	//Lägga testfunktioner separat
	//höger-klick (och vänster-klick) ska fungera i FF, Chrome och IE11
	//byta namn på html-filen


	//NICE TO HAVE
	//_kunna mata in flera polygoner_
	//flagga om man får rita fler än 1 polygon
	//om man har flera polygoner, använda "flagga" för att bestämma om dom får överlappa varandra.
	//polygon som inte är "aktuell" ritas utan punkterna (cirklar)
	//aktuell polygon är blå
	//funktion som delar upp segment (ex i två eller 10 delar)
	//beräkna omkrets på polygon
	//beräkna mass-centrum för polygonen

	//WONT DO
	//onmousemove rita linje mellan sista segmentets.p2 och muspekaren
	//onmousemove vid flytt av linje rita segmenten som flyttas


	var ctx;
	var IWIDTH=0;
	var IHEIGHT=0;
	var minDistance = 10;
	var closePolygonMinimumDistance=5;
	var firstPolygon= new polygon();
	var enforceClockWise=false;
	var useIntegerCoords=true;

	var polygonArray = new Array();
//	var anyPolygonSelected = false;
//	var selectedPolygonIndex = -1;


	function init() {
		var canvas = document.getElementById("canvas");
		IWIDTH=canvas.width;
		IHEIGHT=canvas.height;
			if (canvas.getContext) {
			ctx = canvas.getContext("2d");
		}
		
	}

	function rensaHelt(){
		firstPolygon.segments=[];
		firstPolygon.closed=false;
		firstPolygon.seed=false;
		clearTheCanvas();
		
		//AP radera alla polygoner
	}

	function handleClick(isLeftClick,nyKlickadPunkt){
		hanteradPolygon=firstPolygon;
		//om det var ett vänster-klick
		if(isLeftClick){
			//Om polygonen är stängd
			if(hanteradPolygon.closed){
				//om punkt markerad för flyttning, dvs moveMode
				if(hanteradPolygon.moveMode){
					//om punkten inte är för nära nån annan
					if(checkIfCloseToPoint(hanteradPolygon.segments,nyKlickadPunkt,minDistance)<0){
						//om punktens närmaste linjesegment inte skär nåt annat segment
						if(!checkIfMovedIntersects(hanteradPolygon.segments,nyKlickadPunkt,hanteradPolygon.movePointIndex)){
							//flytta movePointIndex till nya punkten
							hanteradPolygon.segments[hanteradPolygon.movePointIndex].p1.copyValues(nyKlickadPunkt); //kopierar värdena för att det fortfarande ska vara samma objekt
							hanteradPolygon.moveMode=false;
						}
					}
				}
				else{//om ingen punkt är markerad för flyttning (dvs ej moveMode)
					var nearPointIndex=checkIfCloseToPoint(hanteradPolygon.segments,nyKlickadPunkt,minDistance);
					if(nearPointIndex>-1){
						hanteradPolygon.moveMode=true;
						hanteradPolygon.movePointIndex=nearPointIndex;
					}
					else{
						//om klickningen är nära linje, sätt in ny punkt
						var tempVar = checkIfCloseToLine(hanteradPolygon.segments,nyKlickadPunkt,minDistance);
						if(tempVar[0]){
							//avrundar ev koordinaterna för att få heltal
							if(useIntegerCoords){
								tempVar[2].x=Math.round(tempVar[2].x);
								tempVar[2].y=Math.round(tempVar[2].y);
							}
							//lägger till ny punkt inne i segment-arrayen
							hanteradPolygon.insertPoint(tempVar[2],tempVar[1]);//newPoint,index
						}
					}
				}
			}
			//Om polygonen inte är stängd (eller inte ännu finns)
			else{
				//är det första segmentet eller?
				if(hanteradPolygon.segments.length>0){
					//klickar användaren nära första punkten?
					if(distBetweenPoints(nyKlickadPunkt,hanteradPolygon.segments[0].p1)<closePolygonMinimumDistance){
						//om polygonen har minst 2 segment redan
						if(hanteradPolygon.segments.length>=2){
							//kolla att segmentet mellan sista punkten och första punkten inte skär nån linje
							var nyttSegment = new segment(hanteradPolygon.segments[hanteradPolygon.segments.length-1].p2,hanteradPolygon.segments[0].p1);
							if(!checkIfIntersect(hanteradPolygon.segments,nyttSegment,true)){
								hanteradPolygon.segments.push(nyttSegment);
								hanteradPolygon.close();
							}
						}
					}
					else{
						//om linjen inte skär nån annan linje, eller är för nära nån punkt så lägg till punkten
						console.log("antal segment"+hanteradPolygon.segments.length);
						var nyttSegment = new segment(hanteradPolygon.segments[hanteradPolygon.segments.length-1].p2,nyKlickadPunkt);
						if(!checkIfIntersect(hanteradPolygon.segments,nyttSegment,false)){
							if(checkIfCloseToPoint(hanteradPolygon.segments,nyKlickadPunkt,minDistance)<0){
								hanteradPolygon.segments.push(nyttSegment);
							}
						}
					}
				}
				else{//om seed eller några segment ännu inte finns
					if(!hanteradPolygon.seed){
						console.log("första punkten");
						hanteradPolygon.seed=nyKlickadPunkt;
					}
					else{
						//om den inte är för nära första punkten
						if(checkIfCloseToPoint(hanteradPolygon.seed,nyKlickadPunkt,minDistance)<0){
							console.log("första segmentet");
							var nyttSegment = new segment(hanteradPolygon.seed,nyKlickadPunkt);
							hanteradPolygon.segments.push(nyttSegment);
						}
					}
				}
			}
		}
		//om det var ett högerklick
		else{
			//om polygonen är stängd
			if(hanteradPolygon.closed){
				if(hanteradPolygon.moveMode){
					//avbryter "flyttläge"
					hanteradPolygon.moveMode=false;
					hanteradPolygon.movePointIndex=-1;
				}
				else{//inte "flyttläge"
					//Om det är på en punkt, ta bort den om det är fler än tre punkter totalt
					var nearPointIndex=checkIfCloseToPoint(hanteradPolygon.segments,nyKlickadPunkt,minDistance);
					if(nearPointIndex>-1){
						//om polygonen har fler än tre sidor går det ta bort en punkt
						if(hanteradPolygon.segments.length>3){
							//plocka ut den valda punkten
							hanteradPolygon.ejectPoint(nearPointIndex);
						}
					}
					//radera element om högerklicka på på segment
					else{
						//om klickningen är nära linje, sätt in ny punkt
						var tempVar = checkIfCloseToLine(hanteradPolygon.segments,nyKlickadPunkt,minDistance);
						if(tempVar[0]){//true om det klickades tillräckligt nära ett segment
							//tempVar[1] berättar vilket segment
							//flyttar startpunkten
							hanteradPolygon.revolFirstIndex(tempVar[1]);
							//öppnar polygonen och tar bort sista elementet
							hanteradPolygon.closed=false;
							hanteradPolygon.segments.pop();
						}
					}
				}
			}
			//om polygonen är öppen
			else{
				//ta bort senaste inmatade punkten
				
				
				if(hanteradPolygon.segments.length==0){
					hanteradPolygon.seed=false;
					console.log("tog bort seed");
				}
				hanteradPolygon.segments.pop();
				console.log("segment kvar"+hanteradPolygon.segments.length);
			}
		}
		hanteradPolygon.gShoeLace();
		drawPolygon(hanteradPolygon);
	}

	//---------------------------------------------------------------------
	//*************************
	//********objekt***********

	//---polygon---------------------------
	function polygon(){
		this.segments = new Array();
		this.closed = false;
		this.clockWise = false;
		this.area = 0;
		this.seed=false;
		this.moveMode=false;
		this.movePointIndex=-1;
		this.selected=true;
		

		
		//angränsar till vilka grannar, vid vilket segment
		//metod för att stänga polygon
		//metod för att flytta punkt?
		
		//metoder
		this.close=close;
		this.insertPoint=insertPoint;
		this.ejectPoint=ejectPoint;
		this.reversePolygon=reversePolygon;
		this.gShoeLace=gShoeLace;
		this.revolFirstIndex=revolFirstIndex;
	}

	//stänger polygonen
	function close(){
		this.closed=true;
		//beräknar arean och kollar om den är ritad medurs eller moturs
		this.gShoeLace();
		//om den är moturs 
		if(!this.clockWise&&document.getElementById("checkboxEnforceClockwise").checked){
			this.reversePolygon();
		}
	}



	</script>
	</head>
	<body oncontextmenu="return false;" onload="init();">
		<canvas id="canvas" width="1000" height="400" onClick="canvasVansterKlickad(event,this.id)" oncontextmenu="canvasHogerKlickad(event,this.id);"></canvas>
		<BR>
		<input type="checkbox" id="checkboxEnforceClockwise">Enforce clockwise<br>
		<button type="button" onClick="firstPolygon.gShoeLace();alert(firstPolygon.area+'\n'+firstPolygon.clockWise)">Gauss shoelace</button>
		<button type="button" onClick="rensaHelt()">rensa</button>


		<button type="button" onClick="testFunk()">test</button>
		<button type="button" onClick="testFunk2()">längd eller closed</button>
		<button type="button" onClick="testFunk3()">testfunk3</button>
		<button type="button" onClick="firstPolygon.reversePolygon();drawPolygon(firstPolygon)">ändra riktning</button>
		<button type="button" onClick="firstPolygon.revolFirstIndex(3);drawPolygon(firstPolygon)">ändra första</button>
		<button type="button" onClick="drawPolygon(firstPolygon)">drawPolygon</button>


	</body>
</html>
